import path from "path";
import { readFilesContent, saveObjectArrayToFile } from "./files.utils"
import { analyzeSvg, cleanSvg, SvgResult } from "./svgAnalysis.utils";
import { applyTransformation, calculateTransformation, SvgTransform } from "./svgTransform";
import { fileURLToPath } from 'url';
import { transformSvg } from "./svgTransformation";
import { addContentHashToIcons } from "./hash.utils";
import { writeFileSync } from "fs";
import { askYN } from "./cli.utils";
import { capitalize } from "./others";
import { generateConstants } from "./generate.utils";

type WithAliases = SvgTransform & { aliases: string[] }
export type WithCode = WithAliases & { code: string }
const syncIcons = async (prefix: string, sourcePath: string, logsPath: string): Promise<WithCode[]> => {
    const filesData = readFilesContent(sourcePath)
    const analysisData = filesData.map(c => analyzeSvg(c))
    const dataWithIssues = analysisData.filter(c => c.issues.length)
    if (dataWithIssues.length === 0) console.info("No errors")

    const displayIssue = (cur: SvgResult) => `issues: ${cur.name} \n ${cur.issues.map(c => ` - ${c.type}: ${c.message}\n`).join("")}`
    dataWithIssues.forEach(c => console.info(displayIssue(c)))

    const confirmation = await askYN('Do you want to continue?')
    if (!confirmation) throw Error('❌ Operation canceled')


    let icons: SvgResult[] = []
    for (let i = 0; i < analysisData.length; i++) {
        const element = analysisData[i];
        if (element.issues.length === 0) {
            icons.push(element)
            continue
        }
        const cleanContent = await cleanSvg(element.content)
        icons.push({ ...element, content: cleanContent })
    }
    const data = icons.map(c => calculateTransformation(c, 512))
    saveObjectArrayToFile(`${logsPath}/_data.json`, data)
    const res = data.map(c => applyTransformation(c))
    saveObjectArrayToFile(`${logsPath}/_res.json`, res)
    const optimal = res.map(c => transformSvg(c, 512))
    saveObjectArrayToFile(`${logsPath}/_optimal.json`, optimal)
    const withHash = addContentHashToIcons(optimal)
    saveObjectArrayToFile(`${logsPath}/_withHash.json`, withHash)
    const duplicated: string[] = []
    const withoutRepetition = withHash.reduce((a, c): Record<string, WithAliases> => {
        if (!a[c.hash]) return { ...a, [c.hash]: { ...c, aliases: [] } }
        duplicated.push(`duplicated: ${c.name}  -->  ${a[c.hash].name}`)
        return { ...a, [c.hash]: { ...a[c.hash], aliases: [...a[c.hash].aliases, c.name] } }
    }, {})
    if (duplicated.length) {
        console.info("ℹ️ Duplicated icons were removed removed")
        duplicated.forEach((c, i) => console.info(i + 1, c));
    }
    const withoutRepetitionArray = Object.values(withoutRepetition)
    saveObjectArrayToFile(`${logsPath}/_withoutRepetitionArray.json`, withoutRepetitionArray)

    const withCode = withoutRepetitionArray.map(c => ({ ...c, code: `${prefix}${capitalize(c.name)}` }))

    return withCode
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const baseSolidPath = path.resolve(__dirname, `../src/assets/base/solid`);
const baseRegularPath = path.resolve(__dirname, `../src/assets/base/regular`);
const baseBrandPath = path.resolve(__dirname, `../src/assets/base/brands`);

const communitySolidPath = path.resolve(__dirname, `../src/assets/community/solid`);
const communityRegularPath = path.resolve(__dirname, `../src/assets/community/regular`);
const communityBrandPath = path.resolve(__dirname, `../src/assets/community/brands`);
const communityGradientPath = path.resolve(__dirname, `../src/assets/community/gradient`);

const logsPath = path.resolve(__dirname, `../logs`);
const publicPath = path.resolve(__dirname, `../../../apps/docs/public/icons`);

const baseSolid = await syncIcons('solid', baseSolidPath, logsPath)
const baseRegular = await syncIcons('regular', baseRegularPath, logsPath)
const baseBrand = await syncIcons('brands', baseBrandPath, logsPath)
const communitySolid = await syncIcons('solid', communitySolidPath, logsPath)
const communityRegular = await syncIcons('regular', communityRegularPath, logsPath)
const communityBrand = await syncIcons('brands', communityBrandPath, logsPath)
const communityGradient = await syncIcons('gradient', communityGradientPath, logsPath)

const iconsData = [...baseSolid, ...baseRegular, ...baseBrand, ...communitySolid, ...communityRegular, ...communityBrand, ...communityGradient]

// 1. write icons.ts: file with many export icons as string
const SVGsConstants = generateConstants(iconsData)
writeFileSync(path.resolve(__dirname, `../src/gen/icons.ts`), SVGsConstants);

// 2. write metadata: file used to browser icons
const content = [
    '// Auto-generated by genSvg.js',
    'export type Metadata = { name: string, code: string, aliases: string[] }',
    `export const metadata: Metadata[] = [\n${iconsData.map(c => `{ name: '${c.name}', code: '${c.code}', aliases: [${c.aliases.map(c => `'${c}'`).join(', ')}] }`).join(",\n")}]`,
].join('\n');
writeFileSync(path.resolve(__dirname, `../src/gen/metadata.ts`), content);

// 3. write icons on public: icons to display on browser
const confirmation = await askYN('Confirm to write on docs/public?')
if (confirmation) iconsData.forEach(c => writeFileSync(path.resolve(publicPath, `${c.code}.svg`), c.content))
else console.info("❌ Operation canceled")
